#!/usr/bin/env python
""" myke -- the 0.2% of make that does 50% of what I need
"""

def usage():
    print >>stderr, '''\
Usage: %s [-s|--silent] [-n|--just-print] [target]
       Makefile is always "Makefile".''' % argv[0]
    exit( 1 )


from sys import argv, stdout, stderr, exit
from os import getenv, stat, stat_float_times, system

progname = "myke"
Makefile = "Makefile"
be_silent = False
just_print = False
whitespace = [ ' ', '\t', '\\\n', '\n' ]


def myke( target=None ):
    vardict = VarDict()
    dependencies = {}  # { target: list_of_subtarget... }
    scripts = {}       # { target: list_of_commands... }

    target = read_Makefile( vardict, dependencies, scripts, target )
    times = {}
    stat_float_times()  # Makes stat() use 'em if it's got 'em.
    check_dependencies( target, dependencies, scripts, times )
    if times[ target ] != "MAKE":
        message = progname+": Nothing to be done for "+repr(target)+"."
        raise MykeException( progname+": message, 0 )
    build( target, dependencies, times, scripts )


def read_Makefile( vardict, dependencies, scripts, target=None ):
    current_command_target = None
    tab = '\t'

    with open( Makefile, 'r' ) as M:
        line = ""
        lineno = 1
        while True:
            lineno += line.count( '\n' )
            line = read_continuation_lines( M )
            if line == "":
                break

            line = substitute_vars( line, lineno, vardict )

            # blank line or comment:
            p = skipWhiteSpace( line, 0 )
            if p == len( line )  or  line[p] == '#':
                continue

            # command line:
            if line[0] == tab:
                if current_command_target:
                    scripts[ current_command_target ].append( line[ 1: ] )
                    # (Newlines are removed after printing before running.)
                    continue

                else:
                    complain( line, lineno, 1, 
                              "Command isn't directly under a target.  Stop." )

            token = get_token( line, 0, whitespace + [ ':', '=' ] )
            p += len( token )

            # setting a variable:
            if token and line[ p ] == '=':
                p += len( '=' )
                vardict[ token ] = " ".join( split_at_whitespace( line[p:] ) )
                current_command_target = None
                continue

            # target: dependencies line:
            elif token and line[p] == ':':
                p += len( ':' )
                if token in dependencies:
                    complain( line, lineno, 0,
                              "Extra rule for target "+repr(token)+".  Stop." )

                dependencies[ token ] = split_at_whitespace( line[ p : ] )
                current_command_target = token
                if target == None:
                    target = token  # first target in the file
                scripts[ token ] = []
                continue

            else:
                complain( line, lineno, 0,
                          "Can't parse.  Stop." )

    return target

            
def check_dependencies( target, dependencies, scripts, times, parent=None ):
    if target in times:
        return

    try:
        my_time = stat( target ).st_mtime
        if not target in dependencies: # i.e., no rule for target,
            times[ target ] = my_time
            return

    except OSError:
        my_time = None
        if not target in dependencies:
            message = progname + ": *** No rule to make target " + repr(target)
            if parent:
                message += ", needed by " + repr(parent)
            raise MykeException( message + ".  Stop.", 1 )

    times[ target ] = "CHECKING"
    latest_dep = None
    for dep in dependencies[ target ]:
        if times.get( dep ) == "CHECKING":
            print >>stderr, progname+": Circular", dep,"<-",dep,
            print >>stderr, "dependency dropped."
            continue

        check_dependencies( dep, dependencies, scripts, times, parent=target )
        latest_dep = latest_of( latest_dep, times[ dep ] )
    if my_time == None:
        if scripts[ target ]:
            times[ target ] = "MAKE"
        else:
            times[ target ] = latest_dep
    else:
        if my_time == latest_of( my_time, latest_dep ):
            times[ target ] = my_time
        else:
            times[ target ] = "MAKE"


def latest_of( a, b ):
    if a == "MAKE"  or  b == "MAKE":
        return "MAKE"

    return max( a, b )



def build( target, dependencies, times, scripts ):
    if times[ target ] != "MAKE":
        return

    times[ target ] = "MAKING"

    for dep in dependencies[ target ]:
        build( dep, dependencies, times, scripts )

    for command in scripts[ target ]:
        if not be_silent:
            print command.rstrip()
        if not just_print:
            whites = [ '\t', '\\\n', '\n' ]
            command = " ".join( split_at_whitespace( command, whites ) )
            retcode = system( command )
            if retcode != 0:
                err, sig = retcode / 256, retcode % 256
                message = progname+": *** [" + target + "] Error " + str(err)
                raise MykeException( message, err )

    times[ target ] = "MADE"


def read_continuation_lines( f ):
    """ Read lines until EOF or line not ending in backslash.
        single string returned including all backslashes and newlines.
    """
    whole_line = ""
    while True:
        line = f.readline()
        if line == "":
            return whole_line

        if line[ -1 ] != '\n':  # Last line with no newline:
            line += '\n'        # myke counts on it.
        whole_line += line
        if len(line) < 2  or  line[ -2 ] != '\\':
            return whole_line

    
class VarDict:
    """ Variable dictionary just for myke.  if d = VarDict() then
        d[key] = value    sets myke variable;
        d[key]            gets from myke variable, else os.environ, else "".
    """

    def __init__( self ):
        self.d = {}


    def __setitem__( self, varname, value ):
        self.d[ varname ] = value


    def __getitem__( self, varname ):
        if varname in self.d:
            return self.d[ varname ]
        else:
            return getenv( varname, "" )


    def __repr__( self ):
        return repr( self.d )


def substitute_vars( line, lineno, vardict ):
    #  $v  $_  ${blah}  $(blah)  or  $$
    parens = { "(": ")", "{": "}" }
    p = 0
    result = ""
    while p < len( line ):
        q = line[p:].find( '$' )
        if q == -1:
            break

        result += line[ p : p + q ]
        p += ( q + len( '$' ) )
        if line[p].isalpha()  or  line[p] == '_':
            varname = line[p]
            p += len(varname)
        elif line[p] == '$':  # $$ stands for $
            p += len("$")
            result += "$"
            continue

        elif line[p] in parens:
            closer = parens[ line[p] ]
            p += len( line[p] )
            mcguffins = whitespace + [ c for c in "$(){}=:" ]
            varname = get_token( line, p, mcguffins ) 
            p += len( varname )
            if varname == ""  or  line[p] != closer:
                complain( line, lineno, p, "Bad long variable reference." )

            p += len(closer)
        else:
            complain( line, lineno, p, "Bad variable reference." )

        result += vardict[ varname ]

    return result + line[ p: ]


def skipWhiteSpace( line, p, mcguffins=whitespace ):
    while True:
        q = mcguffin_len( line[ p: ], mcguffins )
        if q == None:
            return p

        p += q
            

def split_at_whitespace( string, mcguffins=whitespace ):
    result = []
    p = 0
    while p < len( string ):
        chunk = get_token( string, p, mcguffins )
        p += len( chunk )
        p += mcguffin_len( string[ p : ], mcguffins )
        if chunk != "":
            result.append( chunk )
        while p < len( string ) and string[ p ] in mcguffins:
            p += 1
    return result


def get_token( line, p, mcguffins=whitespace ):
    q = find_any( line[ p: ], mcguffins )
    if q == -1:  # In this program it's strange not to find a newline...
        return line[ p: ]

    else:
        return line[ p: p+q ]


def mcguffin_len( string, mcguffins ):
    for substr in mcguffins:
        if string.startswith( substr ):
            return len( substr )
        
    return None


def find_any( string, mcguffins ):
    """ find first instance of...
            any chars in mcguffins if it's a string
            any strings in mcguffins if it's a list.
    """
    first = len( string )
    for substr in mcguffins:
        p = string.find( substr )
        if p >= 0  and  p < first:
            first = p
    if first == len( string ):
        return -1
    else:
        return first


class MykeException( Exception ):
    pass


def complain( line, lineno, p, complaint ):
    """ Complain about line # lineno, without echoing the line,
        but count newlines before position p in line number.
        p should point at or before newline of the offending line.
    """
    lineno += line[ 0 : p ].count( '\n' )
    message = Makefile + ":" + str(lineno) + ": *** " + complaint
    raise MykeException( message, 1 )


if __name__ == "__main__":
   if len(argv) > 0:
       progname = argv[0]
       args = argv[ 1: ]
       while len(args) > 0 and args[0].startswith( '-' ):
           if args[0] in [ "-s", "--silent" ]:
               be_silent = True
           elif args[0] in [ "-n", "--just-print" ]:
               just_print = True
           else:
               usage()

           args = args[ 1: ]
   if len(args) > 1:
       usage()
   try:
       myke( *args )
   except MykeException as e:
       msg, err = e
       print >>stderr, msg
       exit( err )


